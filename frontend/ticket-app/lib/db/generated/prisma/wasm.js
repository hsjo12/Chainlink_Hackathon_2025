
/* !!! This is code generated by Prisma. Do not edit directly. !!!
/* eslint-disable */

Object.defineProperty(exports, "__esModule", { value: true });

const {
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  getPrismaClient,
  sqltag,
  empty,
  join,
  raw,
  skip,
  Decimal,
  Debug,
  objectEnumValues,
  makeStrictEnum,
  Extensions,
  warnOnce,
  defineDmmfProperty,
  Public,
  getRuntime,
  createParam,
} = require('./runtime/wasm-engine-edge.js')


const Prisma = {}

exports.Prisma = Prisma
exports.$Enums = {}

/**
 * Prisma Client JS version: 6.10.1
 * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
 */
Prisma.prismaVersion = {
  client: "6.10.1",
  engine: "9b628578b3b7cae625e8c927178f15a170e74a9c"
}

Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError
Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError
Prisma.PrismaClientInitializationError = PrismaClientInitializationError
Prisma.PrismaClientValidationError = PrismaClientValidationError
Prisma.Decimal = Decimal

/**
 * Re-export of sql-template-tag
 */
Prisma.sql = sqltag
Prisma.empty = empty
Prisma.join = join
Prisma.raw = raw
Prisma.validator = Public.validator

/**
* Extensions
*/
Prisma.getExtensionContext = Extensions.getExtensionContext
Prisma.defineExtension = Extensions.defineExtension

/**
 * Shorthand utilities for JSON filtering
 */
Prisma.DbNull = objectEnumValues.instances.DbNull
Prisma.JsonNull = objectEnumValues.instances.JsonNull
Prisma.AnyNull = objectEnumValues.instances.AnyNull

Prisma.NullTypes = {
  DbNull: objectEnumValues.classes.DbNull,
  JsonNull: objectEnumValues.classes.JsonNull,
  AnyNull: objectEnumValues.classes.AnyNull
}





/**
 * Enums
 */
exports.Prisma.TransactionIsolationLevel = makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
});

exports.Prisma.EventScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  imageUrl: 'imageUrl',
  bannerUrl: 'bannerUrl',
  category: 'category',
  location: 'location',
  startDate: 'startDate',
  endDate: 'endDate',
  timezone: 'timezone',
  currency: 'currency',
  organizerAddress: 'organizerAddress',
  ticketAddress: 'ticketAddress',
  launchpadAddress: 'launchpadAddress',
  marketAddress: 'marketAddress',
  platformFeePercent: 'platformFeePercent',
  royaltyFeePercent: 'royaltyFeePercent',
  maxPerWallet: 'maxPerWallet',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};

exports.Prisma.TicketTypeScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  name: 'name',
  description: 'description',
  price: 'price',
  totalSupply: 'totalSupply'
};

exports.Prisma.TicketValidationScalarFieldEnum = {
  id: 'id',
  contractAddress: 'contractAddress',
  tokenId: 'tokenId',
  eventId: 'eventId',
  ticketTypeId: 'ticketTypeId',
  isUsed: 'isUsed',
  usedAt: 'usedAt',
  validatedBy: 'validatedBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};

exports.Prisma.SortOrder = {
  asc: 'asc',
  desc: 'desc'
};

exports.Prisma.QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
};

exports.Prisma.NullsOrder = {
  first: 'first',
  last: 'last'
};


exports.Prisma.ModelName = {
  Event: 'Event',
  TicketType: 'TicketType',
  TicketValidation: 'TicketValidation'
};
/**
 * Create the Client
 */
const config = {
  "generator": {
    "name": "client",
    "provider": {
      "fromEnvVar": null,
      "value": "prisma-client-js"
    },
    "output": {
      "value": "H:\\Keep\\2025_chainlink_hackathon\\Chainlink_Hackathon_2025\\frontend\\ticket-app\\lib\\db\\generated\\prisma",
      "fromEnvVar": null
    },
    "config": {
      "engineType": "library"
    },
    "binaryTargets": [
      {
        "fromEnvVar": null,
        "value": "windows",
        "native": true
      }
    ],
    "previewFeatures": [
      "driverAdapters"
    ],
    "sourceFilePath": "H:\\Keep\\2025_chainlink_hackathon\\Chainlink_Hackathon_2025\\frontend\\ticket-app\\prisma\\schema.prisma",
    "isCustomOutput": true
  },
  "relativeEnvPaths": {
    "rootEnvPath": null,
    "schemaEnvPath": "../../../../.env"
  },
  "relativePath": "../../../../prisma",
  "clientVersion": "6.10.1",
  "engineVersion": "9b628578b3b7cae625e8c927178f15a170e74a9c",
  "datasourceNames": [
    "db"
  ],
  "activeProvider": "postgresql",
  "inlineDatasources": {
    "db": {
      "url": {
        "fromEnvVar": "DATABASE_URL",
        "value": null
      }
    }
  },
  "inlineSchema": "// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?\n// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init\n\ngenerator client {\n  provider        = \"prisma-client-js\"\n  output          = \"../lib/db/generated/prisma\"\n  previewFeatures = [\"driverAdapters\"]\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Event {\n  id          String  @id @default(cuid())\n  title       String\n  description String\n  imageUrl    String?\n  bannerUrl   String?\n  category    String // \"concert\", \"sports\", \"theater\", \"conference\", etc.\n  location    String // Venue name or address\n\n  // Event details\n  startDate DateTime\n  endDate   DateTime\n  timezone  String   @default(\"UTC\")\n  currency  String[] @default([\"ETH\"])\n\n  // Organizer\n  organizerAddress String // Wallet address of the organizer\n  ticketAddress    String? // Deployed ticket NFT contract address\n  launchpadAddress String? // Launchpad contract address \n  marketAddress    String? // Market contract address for secondary sales\n\n  // Fee structure\n  platformFeePercent Decimal @default(2.5) // Platform fee percentage\n  royaltyFeePercent  Decimal @default(0.1) // Organizer royalty on resales\n\n  // Tickets for this event\n  ticketTypes  TicketType[]\n  validations  TicketValidation[]\n  maxPerWallet Int                @default(4)\n\n  // Timestamps\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@map(\"events\")\n}\n\nmodel TicketType {\n  id      String @id @default(cuid())\n  eventId String\n  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)\n\n  name        String // \"General Admission\", \"VIP\", \"Early Bird\", etc.\n  description String?\n  price       Decimal // Base price in the selected currency\n\n  // Supply details\n  totalSupply       Int // Total number of tickets available\n  ticketvalidations TicketValidation[]\n\n  @@map(\"ticket_types\")\n}\n\nmodel TicketValidation {\n  id              String     @id @default(cuid())\n  contractAddress String //NFT contract address\n  tokenId         String     @unique //NFT token ID\n  eventId         String\n  event           Event      @relation(fields: [eventId], references: [id], onDelete: Cascade)\n  ticketTypeId    String\n  ticketType      TicketType @relation(fields: [ticketTypeId], references: [id], onDelete: Cascade)\n\n  // Validation details\n  isUsed      Boolean   @default(false)\n  usedAt      DateTime?\n  validatedBy String? // Staff member ID or name\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@map(\"ticket_validations\")\n}\n\n// Event indexes  \n// @@index([organizerId], map: \"idx_events_organizer\")\n// @@index([status], map: \"idx_events_status\")\n// @@index([startDate], map: \"idx_events_start_date\")\n// @@index([category], map: \"idx_events_category\")\n\n// Ticket indexes\n// @@index([ownerId], map: \"idx_tickets_owner\") \n// @@index([eventId], map: \"idx_tickets_event\")\n// @@index([status], map: \"idx_tickets_status\")\n// @@index([tokenId], map: \"idx_tickets_token_id\")\n// @@index([ticketTypeId], map: \"idx_tickets_ticket_type\")\n// @@index([ticketValidationId], map: \"idx_tickets_validation\")\n\n// Transaction indexes\n// @@index([buyerId], map: \"idx_transactions_buyer\")\n// @@index([sellerId], map: \"idx_transactions_seller\") \n// @@index([ticketId], map: \"idx_transactions_ticket\")\n// @@index([status], map: \"idx_transactions_status\")\n// @@index([transactionHash], map: \"idx_transactions_hash\")`\n",
  "inlineSchemaHash": "3f82644fdd01e6ff8314a039b5b030accb3681d61a5331e2be908840884e938a",
  "copyEngine": true
}
config.dirname = '/'

config.runtimeDataModel = JSON.parse("{\"models\":{\"Event\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"title\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"description\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"imageUrl\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"bannerUrl\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"category\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"location\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"startDate\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"endDate\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"timezone\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"currency\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"organizerAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"ticketAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"launchpadAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"marketAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"platformFeePercent\",\"kind\":\"scalar\",\"type\":\"Decimal\"},{\"name\":\"royaltyFeePercent\",\"kind\":\"scalar\",\"type\":\"Decimal\"},{\"name\":\"ticketTypes\",\"kind\":\"object\",\"type\":\"TicketType\",\"relationName\":\"EventToTicketType\"},{\"name\":\"validations\",\"kind\":\"object\",\"type\":\"TicketValidation\",\"relationName\":\"EventToTicketValidation\"},{\"name\":\"maxPerWallet\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":\"events\"},\"TicketType\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"eventId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"event\",\"kind\":\"object\",\"type\":\"Event\",\"relationName\":\"EventToTicketType\"},{\"name\":\"name\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"description\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"price\",\"kind\":\"scalar\",\"type\":\"Decimal\"},{\"name\":\"totalSupply\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"ticketvalidations\",\"kind\":\"object\",\"type\":\"TicketValidation\",\"relationName\":\"TicketTypeToTicketValidation\"}],\"dbName\":\"ticket_types\"},\"TicketValidation\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"contractAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"tokenId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"eventId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"event\",\"kind\":\"object\",\"type\":\"Event\",\"relationName\":\"EventToTicketValidation\"},{\"name\":\"ticketTypeId\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"ticketType\",\"kind\":\"object\",\"type\":\"TicketType\",\"relationName\":\"TicketTypeToTicketValidation\"},{\"name\":\"isUsed\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"usedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"validatedBy\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"}],\"dbName\":\"ticket_validations\"}},\"enums\":{},\"types\":{}}")
defineDmmfProperty(exports.Prisma, config.runtimeDataModel)
config.engineWasm = {
  getRuntime: async () => require('./query_engine_bg.js'),
  getQueryEngineWasmModule: async () => {
    const loader = (await import('#wasm-engine-loader')).default
    const engine = (await loader).default
    return engine
  }
}
config.compilerWasm = undefined

config.injectableEdgeEnv = () => ({
  parsed: {
    DATABASE_URL: typeof globalThis !== 'undefined' && globalThis['DATABASE_URL'] || typeof process !== 'undefined' && process.env && process.env.DATABASE_URL || undefined
  }
})

if (typeof globalThis !== 'undefined' && globalThis['DEBUG'] || typeof process !== 'undefined' && process.env && process.env.DEBUG || undefined) {
  Debug.enable(typeof globalThis !== 'undefined' && globalThis['DEBUG'] || typeof process !== 'undefined' && process.env && process.env.DEBUG || undefined)
}

const PrismaClient = getPrismaClient(config)
exports.PrismaClient = PrismaClient
Object.assign(exports, Prisma)

